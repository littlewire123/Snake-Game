# 贪吃蛇游戏总体架构

## 一、游戏架构概述

贪吃蛇游戏的核心架构可以分为以下几个部分：

### 1. 游戏界面

- 游戏区域显示
- 得分和当前等级展示
- 操作按钮提供

### 2. 蛇的移动

- 四方向移动（上、下、左、右）
- 蛇身体跟随头部移动
- 移动控制逻辑实现

### 3. 食物生成

- 随机位置生成食物
- 确保食物不在蛇身体上

### 4. 得分系统

- 根据食物数量计算得分
- 根据得分调整游戏难度

### 5. 游戏结束条件

- 蛇撞到自身或游戏边界
- 游戏结束逻辑处理

### 6. 控制方式

- 键盘控制（方向键或WASD）



### 7.拟实现的功能

- 经典模式：经典的贪吃蛇单人玩法
- 挑战模式：随机地图障碍物，速度更快
- 道具模式：随机障碍物，多个食物生成，吃食物后有概率获得随机效果（无敌一段时间，速度变快，速度变慢等）
- 多人联机：多人共同游玩

## 二、技术架构

### 1. 存档格式

##### 要存储的信息：

- 地图信息，食物位置信息，蛇身体每个节点的位置信息，得分

### 2. 编程语言

- 客户端c语言，服务器c++

### 3. 客户端与服务器通信格式

#### 需要通信的数据：

##### （1）客户端给服务器：

- 玩家的指令（移动方向）

##### （2）服务器给客户端：

- 所有玩家的状态，包括蛇的位置、移动方向、得分。
- 定时（固定的时间间隔，20ms或30ms）向所有客户端发送游戏状态更新。

#### 通信格式：

##### （1）传送数据格式：

- 数据总字节数（四字节）

- 数据包个数（四字节）
- 数据包（每个数据包之间用`'\0'`区分，用于数据校验）

##### （2）数据包格式：

- 有效数据长度（开头四字节）
- 数据类型（往后四字节，0：地图数据`struct map_t`，1：玩家蛇的位置数据`struct snake_data`，2：食物位置信息`struct food_t`，3：玩家控制信息`struct direction_t`，4：用户id信息`int32_t`）
- 数据正文，长度为开头的四字节
- 包尾（包分隔符）：`\0`

##### （3）用到的数据结构：

```c
//地图
struct map_t
{
	size_t num;
	size_t width;
	size_t height;
	struct position_t *obstacle_pos;
};

//蛇信息
struct snake_data_t
{
	size_t id;
    size_t num;
    struct position_t *snake_pos;
};

//食物位置
struct food_t
{
    size_t num;
    struct position_t *foods;
};

//移动方向信息（玩家控制）
struct direction_t
{
    //-1 : f方向，0 : 不移动，1 : 正方向
    int move_x;
    int move_y;
};

//位置坐标
struct position_t
{
    size_t x;
    size_t y;
};
```



### 4. 服务器和客户端的任务

##### （1）服务器：

- 维护所有玩家的状态，包括蛇的位置、移动方向、得分，计算碰撞，将碰撞死亡的蛇从存活列表移除。
- 接收客户端发送的移动方向数据。

##### （2）客户端：

- 接收服务器发送来的地图信息，每条蛇的信息，然后打印地图。
- 接收用户的移动操作，发送给服务器。



### 5.服务器游戏逻辑实现细节

##### （1）要维护的数据：

- 玩家状态结构体`struct user_status`，用一个`map<int32_t, user_status> _status`存储
- 食物位置结构体`food_t _foods`
- 地图信息`map_t _map`

##### （2）用到的数据结构：

```
struct user_status
{
	int move_x;
	int move_y;
	
	snake_data_t snake;
};
```

##### （3）服务器运行策略

- 主线程维护游戏状态，并将游戏状态发送给所有连接的客户端（维护一个连接列表，主键套接字，值为连接时生成的用户id），

## 三、遇到的问题

### 1.通信方式

- 问题：游戏要求高实时性且需要保持长连接，现有的应用层协议（http）难以满足要求，若采用ws协议，c语言端封装复杂，工作量大。

- 解决方案：自己基于传输层协议（tcp，udp）封装一个通信协议，用于快速编码解码，避免延迟过高，为了确保数据可靠性采用了基于tcp协议传输，具体协议见第二大点。

### 2.服务器端

- 问题：服务器需要同时接收客户端连接，又要处理游戏逻辑并发送给客户端，无法在一个线程中完成所有工作。
- 解决方案：采用多线程和互斥锁，服务器启动后先创建处理连接和接收客户端消息的子线程，然后再在主线程处理游戏逻辑和发送游戏状态给客户端，采用互斥锁确保线程安全

### 3.用户操作

- 问题：在最初的版本中，用户输入操作指令后要等移动一次的下一次移动才生效，延迟很高

- 问题原因：原因是客户端会被阻塞在`recv`函数，直到服务器发送一次游戏信息后才会取消阻塞往下走，这时才能发送控制信号给服务器，而服务器的策略是移动一次才发送一次游戏数据。

- 解决方案：

  （1）客户端采用多线程技术，同时监听用户输入和服务器信息。缺点是线程之间的数据同步会较为复杂。

  （2）服务器采用一次移动前多次发送游戏状态，可以防止客户端一直阻塞而无法检测用户输入。且可以防止网络丢包导致客户端的游戏状态不能及时更新。

  我们采用的是第二种的方法。

## 四、安全与合规

### 1. 数据安全

- 保护玩家数据，防止泄露和滥用

### 2. 合规审查

- 确保游戏内容和操作符合法律法规